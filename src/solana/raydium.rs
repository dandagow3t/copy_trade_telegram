use borsh::BorshDeserialize;
use solana_client::rpc_client::RpcClient;
use solana_sdk::pubkey::Pubkey;

use super::util::env;

#[derive(Debug)]
pub struct RaydiumPair {
    pub status: u64,
    pub nonce: u64,
    pub max_order: u64,
    pub depth: u64,
    pub base_decimal: u64,
    pub quote_decimal: u64,
    pub state: u64,
    pub reset_flag: u64,
    pub min_size: u64,
    pub vol_max_cut_ratio: u64,
    pub amount_wave_ratio: u64,
    pub base_lot_size: u64,
    pub quote_lot_size: u64,
    pub min_price_multiplier: u64,
    pub max_price_multiplier: u64,
    pub system_decimal_value: u64,
    pub min_separate_numerator: u64,
    pub min_separate_denominator: u64,
    pub trade_fee_numerator: u64,
    pub trade_fee_denominator: u64,
    pub pnl_numerator: u64,
    pub pnl_denominator: u64,
    pub swap_fee_numerator: u64,
    pub swap_fee_denominator: u64,
    pub base_need_take_pnl: u64,
    pub quote_need_take_pnl: u64,
    pub quote_total_pnl: u64,
    pub base_total_pnl: u64,
    pub pool_open_time: u64,
    pub punish_pc_amount: u64,
    pub punish_coin_amount: u64,
    pub orderbook_to_init_time: u64,
    pub swap_base_in_amount: u64,
    pub swap_quote_out_amount: u64,
    pub swap_base2_quote_fee: u64,
    pub swap_quote_in_amount: u64,
    pub swap_base_out_amount: u64,
    pub swap_quote2_base_fee: u64,
    pub base_vault: Pubkey,
    pub quote_vault: Pubkey,
    pub base_mint: Pubkey,
    pub quote_mint: Pubkey,
    pub lp_mint: Pubkey,
    pub open_orders: Pubkey,
    pub market_id: Pubkey,
    pub market_program_id: Pubkey,
    pub target_orders: Pubkey,
    pub withdraw_queue: Pubkey,
    pub lp_vault: Pubkey,
    pub owner: Pubkey,
    pub lp_reserve: u64,
    pub padding: [u64; 3],
}

impl RaydiumPair {
    pub fn fetch_and_deserialize(
        pair_address: &Pubkey,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let rpc_client = RpcClient::new(env("SOLANA_RPC_URL"));
        let account_data = rpc_client.get_account_data(pair_address)?;
        let data = account_data.as_slice();

        Ok(Self {
            status: u64::from_le_bytes(data[0..8].try_into()?),
            nonce: u64::from_le_bytes(data[8..16].try_into()?),
            max_order: u64::from_le_bytes(data[16..24].try_into()?),
            depth: u64::from_le_bytes(data[24..32].try_into()?),
            base_decimal: u64::from_le_bytes(data[32..40].try_into()?),
            quote_decimal: u64::from_le_bytes(data[40..48].try_into()?),
            state: u64::from_le_bytes(data[48..56].try_into()?),
            reset_flag: u64::from_le_bytes(data[56..64].try_into()?),
            min_size: u64::from_le_bytes(data[64..72].try_into()?),
            vol_max_cut_ratio: u64::from_le_bytes(data[72..80].try_into()?),
            amount_wave_ratio: u64::from_le_bytes(data[80..88].try_into()?),
            base_lot_size: u64::from_le_bytes(data[88..96].try_into()?),
            quote_lot_size: u64::from_le_bytes(data[96..104].try_into()?),
            min_price_multiplier: u64::from_le_bytes(data[104..112].try_into()?),
            max_price_multiplier: u64::from_le_bytes(data[112..120].try_into()?),
            system_decimal_value: u64::from_le_bytes(data[120..128].try_into()?),
            min_separate_numerator: u64::from_le_bytes(data[128..136].try_into()?),
            min_separate_denominator: u64::from_le_bytes(data[136..144].try_into()?),
            trade_fee_numerator: u64::from_le_bytes(data[144..152].try_into()?),
            trade_fee_denominator: u64::from_le_bytes(data[152..160].try_into()?),
            pnl_numerator: u64::from_le_bytes(data[160..168].try_into()?),
            pnl_denominator: u64::from_le_bytes(data[168..176].try_into()?),
            swap_fee_numerator: u64::from_le_bytes(data[176..184].try_into()?),
            swap_fee_denominator: u64::from_le_bytes(data[184..192].try_into()?),
            base_need_take_pnl: u64::from_le_bytes(data[192..200].try_into()?),
            quote_need_take_pnl: u64::from_le_bytes(data[200..208].try_into()?),
            quote_total_pnl: u64::from_le_bytes(data[208..216].try_into()?),
            base_total_pnl: u64::from_le_bytes(data[216..224].try_into()?),
            pool_open_time: u64::from_le_bytes(data[224..232].try_into()?),
            punish_pc_amount: u64::from_le_bytes(data[232..240].try_into()?),
            punish_coin_amount: u64::from_le_bytes(data[240..248].try_into()?),
            orderbook_to_init_time: u64::from_le_bytes(data[248..256].try_into()?),
            swap_base_in_amount: u64::from_le_bytes(data[256..264].try_into()?),
            swap_quote_out_amount: u64::from_le_bytes(data[264..272].try_into()?),
            swap_base2_quote_fee: u64::from_le_bytes(data[272..280].try_into()?),
            swap_quote_in_amount: u64::from_le_bytes(data[280..288].try_into()?),
            swap_base_out_amount: u64::from_le_bytes(data[288..296].try_into()?),
            swap_quote2_base_fee: u64::from_le_bytes(data[296..304].try_into()?),
            base_vault: Pubkey::try_from_slice(&data[304..336])?,
            quote_vault: Pubkey::try_from_slice(&data[336..368])?,
            base_mint: Pubkey::try_from_slice(&data[368..400])?,
            quote_mint: Pubkey::try_from_slice(&data[400..432])?,
            lp_mint: Pubkey::try_from_slice(&data[432..464])?,
            open_orders: Pubkey::try_from_slice(&data[464..496])?,
            market_id: Pubkey::try_from_slice(&data[496..528])?,
            market_program_id: Pubkey::try_from_slice(&data[528..560])?,
            target_orders: Pubkey::try_from_slice(&data[560..592])?,
            withdraw_queue: Pubkey::try_from_slice(&data[592..624])?,
            lp_vault: Pubkey::try_from_slice(&data[624..656])?,
            owner: Pubkey::try_from_slice(&data[656..688])?,
            lp_reserve: u64::from_le_bytes(data[688..696].try_into()?),
            padding: [
                u64::from_le_bytes(data[696..704].try_into()?),
                u64::from_le_bytes(data[704..712].try_into()?),
                u64::from_le_bytes(data[712..720].try_into()?),
            ],
        })
    }
}
